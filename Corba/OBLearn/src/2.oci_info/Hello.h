// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.2

#ifndef ___Hello_h__
#define ___Hello_h__


#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030200L)
#       error ORBacus version mismatch!
#   endif
#endif

class Hello;
typedef Hello* Hello_ptr;
typedef Hello* HelloRef;

void OBDuplicate(Hello_ptr);
void OBRelease(Hello_ptr);

void OBMarshal(Hello_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(Hello_ptr&, OB::InputStreamImpl*);

typedef OB::ObjVar< Hello > Hello_var;
typedef OB::ObjOut< Hello > Hello_out;

class OBStubImpl_Hello;
typedef OBStubImpl_Hello* OBStubImpl_Hello_ptr;

void OBDuplicate(OBStubImpl_Hello_ptr);
void OBRelease(OBStubImpl_Hello_ptr);

typedef OB::ObjVar< OBStubImpl_Hello > OBStubImpl_Hello_var;

//
// IDL:Hello:1.0
//
class Hello : virtual public ::CORBA::Object
{
    Hello(const Hello&);
    void operator=(const Hello&);

protected:

    static const char* ids_[];

public:

    Hello() { }
    virtual ~Hello() { }

    typedef Hello_ptr _ptr_type;
    typedef Hello_var _var_type;

    static inline Hello_ptr
    _duplicate(Hello_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline Hello_ptr
    _nil()
    {
        return 0;
    }

    static Hello_ptr _narrow(::CORBA::Object_ptr);
    static Hello_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static Hello_ptr _narrow(::CORBA::AbstractBase_ptr);
    static Hello_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:Hello/say_hello:1.0
    //
    virtual void say_hello() = 0;

    //
    // IDL:Hello/shutdown:1.0
    //
    virtual void shutdown() = 0;
};

//
// IDL:Hello:1.0
//
class OBProxy_Hello : virtual public ::Hello,
                      virtual public OBCORBA::Object
{
    OBProxy_Hello(const OBProxy_Hello&);
    void operator=(const OBProxy_Hello&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    OBProxy_Hello() { }
    virtual ~OBProxy_Hello() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:Hello/say_hello:1.0
    //
    void say_hello();

    //
    // IDL:Hello/shutdown:1.0
    //
    void shutdown();
};

//
// IDL:Hello:1.0
//
class OBStubImpl_Hello : virtual public OB::StubImplBase
{
    OBStubImpl_Hello(const OBStubImpl_Hello&);
    void operator=(const OBStubImpl_Hello&);

protected:

    OBStubImpl_Hello() { }

public:

    static inline OBStubImpl_Hello_ptr
    _duplicate(OBStubImpl_Hello_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline OBStubImpl_Hello_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:Hello/say_hello:1.0
    //
    virtual void say_hello() = 0;

    //
    // IDL:Hello/shutdown:1.0
    //
    virtual void shutdown() = 0;
};

//
// IDL:Hello:1.0
//
class OBMarshalStubImpl_Hello : 
    virtual public OBStubImpl_Hello,
    virtual public OB::MarshalStubImpl
{
    OBMarshalStubImpl_Hello(const OBMarshalStubImpl_Hello&);
    void operator=(const OBMarshalStubImpl_Hello&);

protected:

    OBMarshalStubImpl_Hello() { }
    friend class OBProxy_Hello;

public:

    //
    // IDL:Hello/say_hello:1.0
    //
    virtual void say_hello();

    //
    // IDL:Hello/shutdown:1.0
    //
    virtual void shutdown();
};

//
// IDL:Hello:1.0
//
namespace CORBA
{

inline void
release(::Hello_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::Hello_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_Hello_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_Hello_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

#endif
