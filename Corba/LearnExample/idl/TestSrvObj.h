// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.2

#ifndef ___TestSrvObj_h__
#define ___TestSrvObj_h__


#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030200L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace SERVICEOBJ
{

class A;
typedef A* A_ptr;
typedef A* ARef;

extern OB::TypeCodeConst _tc_A;

class B;
typedef B* B_ptr;
typedef B* BRef;

extern OB::TypeCodeConst _tc_B;

class CallBack;
typedef CallBack* CallBack_ptr;
typedef CallBack* CallBackRef;

extern OB::TypeCodeConst _tc_CallBack;

class AB;
typedef AB* AB_ptr;
typedef AB* ABRef;

extern OB::TypeCodeConst _tc_AB;

} // End of namespace SERVICEOBJ

void OBDuplicate(SERVICEOBJ::A_ptr);
void OBRelease(SERVICEOBJ::A_ptr);

void OBMarshal(SERVICEOBJ::A_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(SERVICEOBJ::A_ptr&, OB::InputStreamImpl*);

void OBDuplicate(SERVICEOBJ::B_ptr);
void OBRelease(SERVICEOBJ::B_ptr);

void OBMarshal(SERVICEOBJ::B_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(SERVICEOBJ::B_ptr&, OB::InputStreamImpl*);

void OBDuplicate(SERVICEOBJ::CallBack_ptr);
void OBRelease(SERVICEOBJ::CallBack_ptr);

void OBMarshal(SERVICEOBJ::CallBack_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(SERVICEOBJ::CallBack_ptr&, OB::InputStreamImpl*);

void OBDuplicate(SERVICEOBJ::AB_ptr);
void OBRelease(SERVICEOBJ::AB_ptr);

void OBMarshal(SERVICEOBJ::AB_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(SERVICEOBJ::AB_ptr&, OB::InputStreamImpl*);

namespace SERVICEOBJ
{

typedef OB::ObjVar< A > A_var;
typedef OB::ObjOut< A > A_out;

typedef OB::ObjVar< B > B_var;
typedef OB::ObjOut< B > B_out;

typedef OB::ObjVar< CallBack > CallBack_var;
typedef OB::ObjOut< CallBack > CallBack_out;

typedef OB::ObjVar< AB > AB_var;
typedef OB::ObjOut< AB > AB_out;

} // End of namespace SERVICEOBJ

namespace OBStubImpl_SERVICEOBJ
{

class A;
typedef A* A_ptr;

class B;
typedef B* B_ptr;

class CallBack;
typedef CallBack* CallBack_ptr;

class AB;
typedef AB* AB_ptr;

} // End of namespace OBStubImpl_SERVICEOBJ

void OBDuplicate(OBStubImpl_SERVICEOBJ::A_ptr);
void OBRelease(OBStubImpl_SERVICEOBJ::A_ptr);

void OBDuplicate(OBStubImpl_SERVICEOBJ::B_ptr);
void OBRelease(OBStubImpl_SERVICEOBJ::B_ptr);

void OBDuplicate(OBStubImpl_SERVICEOBJ::CallBack_ptr);
void OBRelease(OBStubImpl_SERVICEOBJ::CallBack_ptr);

void OBDuplicate(OBStubImpl_SERVICEOBJ::AB_ptr);
void OBRelease(OBStubImpl_SERVICEOBJ::AB_ptr);

namespace OBStubImpl_SERVICEOBJ
{

typedef OB::ObjVar< A > A_var;

typedef OB::ObjVar< B > B_var;

typedef OB::ObjVar< CallBack > CallBack_var;

typedef OB::ObjVar< AB > AB_var;

} // End of namespace OBStubImpl_SERVICEOBJ

//
// IDL:SERVICEOBJ:1.0
//
namespace SERVICEOBJ
{

//
// IDL:SERVICEOBJ/A:1.0
//
class A : virtual public ::CORBA::Object
{
    A(const A&);
    void operator=(const A&);

protected:

    static const char* ids_[];

public:

    A() { }
    virtual ~A() { }

    typedef A_ptr _ptr_type;
    typedef A_var _var_type;

    static inline A_ptr
    _duplicate(A_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline A_ptr
    _nil()
    {
        return 0;
    }

    static A_ptr _narrow(::CORBA::Object_ptr);
    static A_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static A_ptr _narrow(::CORBA::AbstractBase_ptr);
    static A_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:SERVICEOBJ/A/opetater_a:1.0
    //
    virtual void opetater_a() = 0;
};

//
// IDL:SERVICEOBJ/B:1.0
//
class B : virtual public ::CORBA::Object
{
    B(const B&);
    void operator=(const B&);

protected:

    static const char* ids_[];

public:

    B() { }
    virtual ~B() { }

    typedef B_ptr _ptr_type;
    typedef B_var _var_type;

    static inline B_ptr
    _duplicate(B_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline B_ptr
    _nil()
    {
        return 0;
    }

    static B_ptr _narrow(::CORBA::Object_ptr);
    static B_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static B_ptr _narrow(::CORBA::AbstractBase_ptr);
    static B_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:SERVICEOBJ/B/opetater_b:1.0
    //
    virtual void opetater_b() = 0;
};

//
// IDL:SERVICEOBJ/CallBack:1.0
//
class CallBack : virtual public ::CORBA::Object
{
    CallBack(const CallBack&);
    void operator=(const CallBack&);

protected:

    static const char* ids_[];

public:

    CallBack() { }
    virtual ~CallBack() { }

    typedef CallBack_ptr _ptr_type;
    typedef CallBack_var _var_type;

    static inline CallBack_ptr
    _duplicate(CallBack_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline CallBack_ptr
    _nil()
    {
        return 0;
    }

    static CallBack_ptr _narrow(::CORBA::Object_ptr);
    static CallBack_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static CallBack_ptr _narrow(::CORBA::AbstractBase_ptr);
    static CallBack_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
    //
    virtual void opetater_callBack(const char* message_) = 0;
};

//
// IDL:SERVICEOBJ/AB:1.0
//
class AB : virtual public ::CORBA::Object
{
    AB(const AB&);
    void operator=(const AB&);

protected:

    static const char* ids_[];

public:

    AB() { }
    virtual ~AB() { }

    typedef AB_ptr _ptr_type;
    typedef AB_var _var_type;

    static inline AB_ptr
    _duplicate(AB_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline AB_ptr
    _nil()
    {
        return 0;
    }

    static AB_ptr _narrow(::CORBA::Object_ptr);
    static AB_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static AB_ptr _narrow(::CORBA::AbstractBase_ptr);
    static AB_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:SERVICEOBJ/AB/a_:1.0
    //
    virtual A_ptr a_() = 0;
    virtual void a_(A_ptr) = 0;

    //
    // IDL:SERVICEOBJ/AB/b_:1.0
    //
    virtual B_ptr b_() = 0;
    virtual void b_(B_ptr) = 0;

    //
    // IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
    //
    virtual void opetater_setCallBack(CallBack_ptr callback_) = 0;
};

} // End of namespace SERVICEOBJ

//
// IDL:SERVICEOBJ:1.0
//
namespace OBProxy_SERVICEOBJ
{

//
// IDL:SERVICEOBJ/A:1.0
//
class A : virtual public ::SERVICEOBJ::A,
          virtual public OBCORBA::Object
{
    A(const A&);
    void operator=(const A&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    A() { }
    virtual ~A() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:SERVICEOBJ/A/opetater_a:1.0
    //
    void opetater_a();
};

//
// IDL:SERVICEOBJ/B:1.0
//
class B : virtual public ::SERVICEOBJ::B,
          virtual public OBCORBA::Object
{
    B(const B&);
    void operator=(const B&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    B() { }
    virtual ~B() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:SERVICEOBJ/B/opetater_b:1.0
    //
    void opetater_b();
};

//
// IDL:SERVICEOBJ/CallBack:1.0
//
class CallBack : virtual public ::SERVICEOBJ::CallBack,
                 virtual public OBCORBA::Object
{
    CallBack(const CallBack&);
    void operator=(const CallBack&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    CallBack() { }
    virtual ~CallBack() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
    //
    void opetater_callBack(const char* message_);
};

//
// IDL:SERVICEOBJ/AB:1.0
//
class AB : virtual public ::SERVICEOBJ::AB,
           virtual public OBCORBA::Object
{
    AB(const AB&);
    void operator=(const AB&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    AB() { }
    virtual ~AB() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:SERVICEOBJ/AB/a_:1.0
    //
    ::SERVICEOBJ::A_ptr a_();
    void a_(::SERVICEOBJ::A_ptr);

    //
    // IDL:SERVICEOBJ/AB/b_:1.0
    //
    ::SERVICEOBJ::B_ptr b_();
    void b_(::SERVICEOBJ::B_ptr);

    //
    // IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
    //
    void opetater_setCallBack(::SERVICEOBJ::CallBack_ptr callback_);
};

} // End of namespace OBProxy_SERVICEOBJ

//
// IDL:SERVICEOBJ:1.0
//
namespace OBStubImpl_SERVICEOBJ
{

//
// IDL:SERVICEOBJ/A:1.0
//
class A : virtual public OB::StubImplBase
{
    A(const A&);
    void operator=(const A&);

protected:

    A() { }

public:

    static inline A_ptr
    _duplicate(A_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline A_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:SERVICEOBJ/A/opetater_a:1.0
    //
    virtual void opetater_a() = 0;
};

//
// IDL:SERVICEOBJ/B:1.0
//
class B : virtual public OB::StubImplBase
{
    B(const B&);
    void operator=(const B&);

protected:

    B() { }

public:

    static inline B_ptr
    _duplicate(B_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline B_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:SERVICEOBJ/B/opetater_b:1.0
    //
    virtual void opetater_b() = 0;
};

//
// IDL:SERVICEOBJ/CallBack:1.0
//
class CallBack : virtual public OB::StubImplBase
{
    CallBack(const CallBack&);
    void operator=(const CallBack&);

protected:

    CallBack() { }

public:

    static inline CallBack_ptr
    _duplicate(CallBack_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline CallBack_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
    //
    virtual void opetater_callBack(const char* message_) = 0;
};

//
// IDL:SERVICEOBJ/AB:1.0
//
class AB : virtual public OB::StubImplBase
{
    AB(const AB&);
    void operator=(const AB&);

protected:

    AB() { }

public:

    static inline AB_ptr
    _duplicate(AB_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline AB_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:SERVICEOBJ/AB/a_:1.0
    //
    virtual ::SERVICEOBJ::A_ptr a_() = 0;
    virtual void a_(::SERVICEOBJ::A_ptr) = 0;

    //
    // IDL:SERVICEOBJ/AB/b_:1.0
    //
    virtual ::SERVICEOBJ::B_ptr b_() = 0;
    virtual void b_(::SERVICEOBJ::B_ptr) = 0;

    //
    // IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
    //
    virtual void opetater_setCallBack(::SERVICEOBJ::CallBack_ptr callback_) = 0;
};

} // End of namespace OBStubImpl_SERVICEOBJ

//
// IDL:SERVICEOBJ:1.0
//
namespace OBMarshalStubImpl_SERVICEOBJ
{

//
// IDL:SERVICEOBJ/A:1.0
//
class A : 
    virtual public OBStubImpl_SERVICEOBJ::A,
    virtual public OB::MarshalStubImpl
{
    A(const A&);
    void operator=(const A&);

protected:

    A() { }
    friend class OBProxy_SERVICEOBJ::A;

public:

    //
    // IDL:SERVICEOBJ/A/opetater_a:1.0
    //
    virtual void opetater_a();
};

//
// IDL:SERVICEOBJ/B:1.0
//
class B : 
    virtual public OBStubImpl_SERVICEOBJ::B,
    virtual public OB::MarshalStubImpl
{
    B(const B&);
    void operator=(const B&);

protected:

    B() { }
    friend class OBProxy_SERVICEOBJ::B;

public:

    //
    // IDL:SERVICEOBJ/B/opetater_b:1.0
    //
    virtual void opetater_b();
};

//
// IDL:SERVICEOBJ/CallBack:1.0
//
class CallBack : 
    virtual public OBStubImpl_SERVICEOBJ::CallBack,
    virtual public OB::MarshalStubImpl
{
    CallBack(const CallBack&);
    void operator=(const CallBack&);

protected:

    CallBack() { }
    friend class OBProxy_SERVICEOBJ::CallBack;

public:

    //
    // IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
    //
    virtual void opetater_callBack(const char* message_);
};

//
// IDL:SERVICEOBJ/AB:1.0
//
class AB : 
    virtual public OBStubImpl_SERVICEOBJ::AB,
    virtual public OB::MarshalStubImpl
{
    AB(const AB&);
    void operator=(const AB&);

protected:

    AB() { }
    friend class OBProxy_SERVICEOBJ::AB;

public:

    //
    // IDL:SERVICEOBJ/AB/a_:1.0
    //
    virtual ::SERVICEOBJ::A_ptr a_();
    virtual void a_(::SERVICEOBJ::A_ptr);

    //
    // IDL:SERVICEOBJ/AB/b_:1.0
    //
    virtual ::SERVICEOBJ::B_ptr b_();
    virtual void b_(::SERVICEOBJ::B_ptr);

    //
    // IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
    //
    virtual void opetater_setCallBack(::SERVICEOBJ::CallBack_ptr callback_);
};

} // End of namespace OBMarshalStubImpl_SERVICEOBJ

//
// IDL:SERVICEOBJ:1.0
//
namespace OBV_SERVICEOBJ
{

} // End of namespace OBV_SERVICEOBJ

//
// IDL:SERVICEOBJ/A:1.0
//
namespace CORBA
{

inline void
release(::SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::SERVICEOBJ::A_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_SERVICEOBJ::A_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, SERVICEOBJ::A_ptr*);
void operator<<=(::CORBA::Any&, SERVICEOBJ::A_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, SERVICEOBJ::A_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::A_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::A_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, SERVICEOBJ::A_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:SERVICEOBJ/B:1.0
//
namespace CORBA
{

inline void
release(::SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::SERVICEOBJ::B_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_SERVICEOBJ::B_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, SERVICEOBJ::B_ptr*);
void operator<<=(::CORBA::Any&, SERVICEOBJ::B_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, SERVICEOBJ::B_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::B_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::B_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, SERVICEOBJ::B_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:SERVICEOBJ/CallBack:1.0
//
namespace CORBA
{

inline void
release(::SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::SERVICEOBJ::CallBack_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_SERVICEOBJ::CallBack_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, SERVICEOBJ::CallBack_ptr*);
void operator<<=(::CORBA::Any&, SERVICEOBJ::CallBack_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, SERVICEOBJ::CallBack_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::CallBack_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::CallBack_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, SERVICEOBJ::CallBack_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:SERVICEOBJ/AB:1.0
//
namespace CORBA
{

inline void
release(::SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::SERVICEOBJ::AB_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_SERVICEOBJ::AB_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, SERVICEOBJ::AB_ptr*);
void operator<<=(::CORBA::Any&, SERVICEOBJ::AB_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, SERVICEOBJ::AB_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::AB_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, SERVICEOBJ::AB_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, SERVICEOBJ::AB_ptr& val)
{
    return any.in() >>= val;
}

#endif
