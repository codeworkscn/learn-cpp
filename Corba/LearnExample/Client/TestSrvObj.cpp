// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.2

#include <OB/CORBAClient.h>
#include <TestSrvObj.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030200L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace SERVICEOBJ
{

::OB::TypeCodeConst _tc_A(
"019749000e00000026000000019368001500000049444c3a534552564943454f424a2f413a312"
"e3000006800020000004100"
);

::OB::TypeCodeConst _tc_B(
"01ef92750e00000026000000019b19001500000049444c3a534552564943454f424a2f423a312"
"e3000000000020000004200"
);

::OB::TypeCodeConst _tc_CallBack(
"01ef92750e00000031000000019b19001c00000049444c3a534552564943454f424a2f43616c6"
"c4261636b3a312e30000900000043616c6c4261636b00"
);

::OB::TypeCodeConst _tc_AB(
"01ef92750e00000027000000019b19001600000049444c3a534552564943454f424a2f41423a3"
"12e3000000003000000414200"
);

} // End of namespace SERVICEOBJ

//
// IDL:SERVICEOBJ/A:1.0
//
const char* SERVICEOBJ::A::ids_[] =
{
    "IDL:SERVICEOBJ/A:1.0",
    0
};

void
OBDuplicate(SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _remove_ref();
}

SERVICEOBJ::A_ptr
SERVICEOBJ::A::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        A_ptr v = 
            dynamic_cast< A_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_SERVICEOBJ::A* val = new OBProxy_SERVICEOBJ::A;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

SERVICEOBJ::A_ptr
SERVICEOBJ::A::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        A_ptr v =
            dynamic_cast< A_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

SERVICEOBJ::A_ptr
SERVICEOBJ::A::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        A_ptr v =
            dynamic_cast< A_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_SERVICEOBJ::A* val = new OBProxy_SERVICEOBJ::A;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

SERVICEOBJ::A_ptr
SERVICEOBJ::A::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
SERVICEOBJ::A::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(SERVICEOBJ::A_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(SERVICEOBJ::A_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    SERVICEOBJ::A_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_SERVICEOBJ::A* _ob_obj = new OBProxy_SERVICEOBJ::A;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = SERVICEOBJ::A::_nil();
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::A_ptr* v)
{
    any.replace(SERVICEOBJ::_tc_A, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::A_ptr v)
{
    SERVICEOBJ::A_ptr val = SERVICEOBJ::A::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, SERVICEOBJ::A_ptr& v)
{
    if(any.check_type(SERVICEOBJ::_tc_A))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< SERVICEOBJ::A_ptr >(val)))
            {
                OBProxy_SERVICEOBJ::A* obj = new OBProxy_SERVICEOBJ::A;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = SERVICEOBJ::A::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:SERVICEOBJ/B:1.0
//
const char* SERVICEOBJ::B::ids_[] =
{
    "IDL:SERVICEOBJ/B:1.0",
    0
};

void
OBDuplicate(SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _remove_ref();
}

SERVICEOBJ::B_ptr
SERVICEOBJ::B::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        B_ptr v = 
            dynamic_cast< B_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_SERVICEOBJ::B* val = new OBProxy_SERVICEOBJ::B;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

SERVICEOBJ::B_ptr
SERVICEOBJ::B::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        B_ptr v =
            dynamic_cast< B_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

SERVICEOBJ::B_ptr
SERVICEOBJ::B::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        B_ptr v =
            dynamic_cast< B_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_SERVICEOBJ::B* val = new OBProxy_SERVICEOBJ::B;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

SERVICEOBJ::B_ptr
SERVICEOBJ::B::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
SERVICEOBJ::B::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(SERVICEOBJ::B_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(SERVICEOBJ::B_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    SERVICEOBJ::B_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_SERVICEOBJ::B* _ob_obj = new OBProxy_SERVICEOBJ::B;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = SERVICEOBJ::B::_nil();
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::B_ptr* v)
{
    any.replace(SERVICEOBJ::_tc_B, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::B_ptr v)
{
    SERVICEOBJ::B_ptr val = SERVICEOBJ::B::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, SERVICEOBJ::B_ptr& v)
{
    if(any.check_type(SERVICEOBJ::_tc_B))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< SERVICEOBJ::B_ptr >(val)))
            {
                OBProxy_SERVICEOBJ::B* obj = new OBProxy_SERVICEOBJ::B;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = SERVICEOBJ::B::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:SERVICEOBJ/CallBack:1.0
//
const char* SERVICEOBJ::CallBack::ids_[] =
{
    "IDL:SERVICEOBJ/CallBack:1.0",
    0
};

void
OBDuplicate(SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _remove_ref();
}

SERVICEOBJ::CallBack_ptr
SERVICEOBJ::CallBack::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        CallBack_ptr v = 
            dynamic_cast< CallBack_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_SERVICEOBJ::CallBack* val = new OBProxy_SERVICEOBJ::CallBack;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

SERVICEOBJ::CallBack_ptr
SERVICEOBJ::CallBack::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        CallBack_ptr v =
            dynamic_cast< CallBack_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

SERVICEOBJ::CallBack_ptr
SERVICEOBJ::CallBack::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        CallBack_ptr v =
            dynamic_cast< CallBack_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_SERVICEOBJ::CallBack* val = new OBProxy_SERVICEOBJ::CallBack;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

SERVICEOBJ::CallBack_ptr
SERVICEOBJ::CallBack::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
SERVICEOBJ::CallBack::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(SERVICEOBJ::CallBack_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(SERVICEOBJ::CallBack_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    SERVICEOBJ::CallBack_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_SERVICEOBJ::CallBack* _ob_obj = new OBProxy_SERVICEOBJ::CallBack;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = SERVICEOBJ::CallBack::_nil();
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::CallBack_ptr* v)
{
    any.replace(SERVICEOBJ::_tc_CallBack, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::CallBack_ptr v)
{
    SERVICEOBJ::CallBack_ptr val = SERVICEOBJ::CallBack::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, SERVICEOBJ::CallBack_ptr& v)
{
    if(any.check_type(SERVICEOBJ::_tc_CallBack))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< SERVICEOBJ::CallBack_ptr >(val)))
            {
                OBProxy_SERVICEOBJ::CallBack* obj = new OBProxy_SERVICEOBJ::CallBack;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = SERVICEOBJ::CallBack::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:SERVICEOBJ/AB:1.0
//
const char* SERVICEOBJ::AB::ids_[] =
{
    "IDL:SERVICEOBJ/AB:1.0",
    0
};

void
OBDuplicate(SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _remove_ref();
}

SERVICEOBJ::AB_ptr
SERVICEOBJ::AB::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        AB_ptr v = 
            dynamic_cast< AB_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_SERVICEOBJ::AB* val = new OBProxy_SERVICEOBJ::AB;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

SERVICEOBJ::AB_ptr
SERVICEOBJ::AB::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        AB_ptr v =
            dynamic_cast< AB_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

SERVICEOBJ::AB_ptr
SERVICEOBJ::AB::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        AB_ptr v =
            dynamic_cast< AB_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_SERVICEOBJ::AB* val = new OBProxy_SERVICEOBJ::AB;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

SERVICEOBJ::AB_ptr
SERVICEOBJ::AB::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
SERVICEOBJ::AB::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(SERVICEOBJ::AB_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(SERVICEOBJ::AB_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    SERVICEOBJ::AB_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_SERVICEOBJ::AB* _ob_obj = new OBProxy_SERVICEOBJ::AB;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = SERVICEOBJ::AB::_nil();
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::AB_ptr* v)
{
    any.replace(SERVICEOBJ::_tc_AB, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, SERVICEOBJ::AB_ptr v)
{
    SERVICEOBJ::AB_ptr val = SERVICEOBJ::AB::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, SERVICEOBJ::AB_ptr& v)
{
    if(any.check_type(SERVICEOBJ::_tc_AB))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< SERVICEOBJ::AB_ptr >(val)))
            {
                OBProxy_SERVICEOBJ::AB* obj = new OBProxy_SERVICEOBJ::AB;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = SERVICEOBJ::AB::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:SERVICEOBJ/A:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_SERVICEOBJ::A::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_SERVICEOBJ::A;
}

const char**
OBProxy_SERVICEOBJ::A::_OB_ids() const
{
    return ::SERVICEOBJ::A::ids_;
}

//
// IDL:SERVICEOBJ/A/opetater_a:1.0
//
void
OBProxy_SERVICEOBJ::A::opetater_a()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::A_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::A_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> opetater_a();
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/B:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_SERVICEOBJ::B::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_SERVICEOBJ::B;
}

const char**
OBProxy_SERVICEOBJ::B::_OB_ids() const
{
    return ::SERVICEOBJ::B::ids_;
}

//
// IDL:SERVICEOBJ/B/opetater_b:1.0
//
void
OBProxy_SERVICEOBJ::B::opetater_b()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::B_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::B_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> opetater_b();
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/CallBack:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_SERVICEOBJ::CallBack::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_SERVICEOBJ::CallBack;
}

const char**
OBProxy_SERVICEOBJ::CallBack::_OB_ids() const
{
    return ::SERVICEOBJ::CallBack::ids_;
}

//
// IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
//
void
OBProxy_SERVICEOBJ::CallBack::opetater_callBack(const char* _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::CallBack_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::CallBack_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> opetater_callBack(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/AB:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_SERVICEOBJ::AB::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_SERVICEOBJ::AB;
}

const char**
OBProxy_SERVICEOBJ::AB::_OB_ids() const
{
    return ::SERVICEOBJ::AB::ids_;
}

//
// IDL:SERVICEOBJ/AB/a_:1.0
//
::SERVICEOBJ::A_ptr
OBProxy_SERVICEOBJ::AB::a_()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::AB_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::AB_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> a_();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

void
OBProxy_SERVICEOBJ::AB::a_(::SERVICEOBJ::A_ptr _ob_a)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::AB_ptr _ob_stubImpl =
                dynamic_cast< OBStubImpl_SERVICEOBJ::AB_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> a_(_ob_a);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/AB/b_:1.0
//
::SERVICEOBJ::B_ptr
OBProxy_SERVICEOBJ::AB::b_()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::AB_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::AB_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> b_();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

void
OBProxy_SERVICEOBJ::AB::b_(::SERVICEOBJ::B_ptr _ob_a)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::AB_ptr _ob_stubImpl =
                dynamic_cast< OBStubImpl_SERVICEOBJ::AB_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> b_(_ob_a);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
//
void
OBProxy_SERVICEOBJ::AB::opetater_setCallBack(::SERVICEOBJ::CallBack_ptr _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_SERVICEOBJ::AB_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_SERVICEOBJ::AB_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> opetater_setCallBack(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:SERVICEOBJ/A:1.0
//
void
OBDuplicate(OBStubImpl_SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_SERVICEOBJ::A_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:SERVICEOBJ/B:1.0
//
void
OBDuplicate(OBStubImpl_SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_SERVICEOBJ::B_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:SERVICEOBJ/CallBack:1.0
//
void
OBDuplicate(OBStubImpl_SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_SERVICEOBJ::CallBack_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:SERVICEOBJ/AB:1.0
//
void
OBDuplicate(OBStubImpl_SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_SERVICEOBJ::AB_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:SERVICEOBJ/A/opetater_a:1.0
//
void
OBMarshalStubImpl_SERVICEOBJ::A::opetater_a()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("opetater_a", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:SERVICEOBJ/B/opetater_b:1.0
//
void
OBMarshalStubImpl_SERVICEOBJ::B::opetater_b()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("opetater_b", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:SERVICEOBJ/CallBack/opetater_callBack:1.0
//
void
OBMarshalStubImpl_SERVICEOBJ::CallBack::opetater_callBack(const char* _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("opetater_callBack", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:SERVICEOBJ/AB/a_:1.0
//
::SERVICEOBJ::A_ptr
OBMarshalStubImpl_SERVICEOBJ::AB::a_()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_get_a_", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down);
            ::SERVICEOBJ::A_var _ob_r;
            try
            {
                OBUnmarshal(_ob_r.inout(), _ob_in);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_unmarshalEx(_ob_down, _ob_ex);
            }
            _OB_postUnmarshal(_ob_down);
            return _ob_r._retn();
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

void
OBMarshalStubImpl_SERVICEOBJ::AB::a_(::SERVICEOBJ::A_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_set_a_", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:SERVICEOBJ/AB/b_:1.0
//
::SERVICEOBJ::B_ptr
OBMarshalStubImpl_SERVICEOBJ::AB::b_()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_get_b_", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down);
            ::SERVICEOBJ::B_var _ob_r;
            try
            {
                OBUnmarshal(_ob_r.inout(), _ob_in);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_unmarshalEx(_ob_down, _ob_ex);
            }
            _OB_postUnmarshal(_ob_down);
            return _ob_r._retn();
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

void
OBMarshalStubImpl_SERVICEOBJ::AB::b_(::SERVICEOBJ::B_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_set_b_", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:SERVICEOBJ/AB/opetater_setCallBack:1.0
//
void
OBMarshalStubImpl_SERVICEOBJ::AB::opetater_setCallBack(::SERVICEOBJ::CallBack_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("opetater_setCallBack", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}
